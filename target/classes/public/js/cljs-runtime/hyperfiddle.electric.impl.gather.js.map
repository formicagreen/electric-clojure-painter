{"version":3,"sources":["hyperfiddle/electric/impl/gather.cljc"],"mappings":"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","names":["hyperfiddle.electric.impl.gather/done!","main","terminator","hyperfiddle.electric.impl.gather/cancel!","temp__5808__auto__","item","n","fexpr__42358","fexpr__42359","hyperfiddle.electric.impl.gather/flush!","next","a__42065__auto__","i__42066__auto__","x__42067__auto__","cljs.core/deref","e42403","_","hyperfiddle.electric.impl.gather/fail!","error","hyperfiddle.electric.impl.gather/sample!","rf","notifier","idle","head","r","e42447","e","e42452","G__42453","G__42454","unused__11925__auto__","self__","G__42470","js/Error","args42468","cljs.core/aclone","this__5330__auto__","writer__5331__auto__","opt__5332__auto__","cljs.core/-write","hyperfiddle.electric.impl.gather/It","hyperfiddle.electric.impl.gather/->It","it","hyperfiddle.electric.impl.gather/transfer!","cljs.core/not","temp__5806__auto__","prev","cljs.core.object_array","e42670","curr","fexpr__42671","t","e42674","fexpr__42675","hyperfiddle.electric.impl.failer/run","fexpr__42677","e42666","hyperfiddle.electric.impl.gather/gather",">>x","G__42678","G__42682","G__42683"],"sourcesContent":["(ns hyperfiddle.electric.impl.gather\n  (:require [hyperfiddle.electric.impl.failer :as failer])\n  #?(:clj (:import (clojure.lang IDeref IFn)))\n  #?(:cljs (:require-macros [hyperfiddle.electric.impl.gather :refer [aget-aset]])))\n\n#?(:clj\n   (defmacro aget-aset [arr idx val]\n     `(let [a# ~arr\n            i# ~idx\n            x# (aget a# i#)]\n        (aset a# i# ~val) x#)))\n\n;; 0: iterator\n;; 1: prev in linked list\n;; 2: next in linked list\n;; 3: next in transfer stack\n;; 4: true if input is ready\n;; 5: true if output can be notified\n;; 6: count of non-terminated flows\n\n(defn ^:static done! [^objects main terminator]\n  (when (zero? (aset main (int 6) (dec (aget main (int 6))))) (terminator)))\n\n(defn ^:static cancel! [^objects main]\n  (when-some [item (aget main (int 2))]\n    (loop [^objects item item]\n      (when-not (identical? item main)\n        (let [n (aget item (int 2))]\n          (aset item (int 1) nil)\n          (aset item (int 2) nil)\n          ((aget item (int 0)))\n          (recur n))))\n    (aset main (int 1) nil)\n    (aset main (int 2) nil)\n    ((aget main (int 0)))))\n\n(defn ^:static flush! [item]\n  (loop [^objects item item]\n    (when (some? item)\n      (let [next (aget-aset item (int 3) nil)]\n        (try @(aget item (int 0))\n             (catch #?(:clj Throwable :cljs :default) _))\n        (recur next)))))\n\n(defn ^:static fail! [^objects main ^objects item error]\n  (cancel! main)\n  (flush! (aget-aset main (int 3) nil))\n  (flush! item)\n  (throw error))\n\n(defn ^:static sample! [^objects main rf notifier]\n  (let [^boolean idle (aget-aset main (int 5) false)\n        ^objects head (aget-aset main (int 3) nil)]\n    (loop [^objects item (aget-aset head (int 3) nil)\n           r (try @(aget head (int 0))\n                  (catch #?(:clj Throwable :cljs :default) e\n                    (fail! main item e)))]\n      (if (nil? item)\n        (do (if (aget main (int 5))\n              (when idle (notifier))\n              (aset main (int 5) ^Object idle)\n              ;; ^ Reflection optimization: no static method RT.aset\n              ;; for (^objects ^int ^boolean), target (^objects ^int ^object)\n              ;; instead.\n              )\n            r)\n        (let [next (aget-aset item (int 3) nil)]\n          (recur next\n            (try (rf r @(aget item (int 0)))\n                 (catch #?(:clj Throwable :cljs :default) e\n                   (fail! main next e)))))))))\n\n(deftype It [main rf notifier terminator]\n  IFn\n  (#?(:clj invoke :cljs -invoke) [it]\n    (locking it (cancel! main)))\n  IDeref\n  (#?(:clj deref :cljs -deref) [it]\n    (locking it (sample! main rf notifier))))\n\n(defn ^:static transfer! [^It it]\n  (let [^objects main (.-main it)]\n    (while (aset main (int 4) (not (aget main (int 4))))\n      (if-some [^objects prev (aget main (int 1))]\n        (let [item (object-array (int 4))\n              ^boolean idle (aget-aset main (int 5) false)]\n          (aset main (int 6) (inc (aget main (int 6))))\n          (aset item (int 1) prev)\n          (aset prev (int 2) item)\n          (aset main (int 1) item)\n          (aset item (int 2) main)\n          (let [n #(locking it\n                     (if (nil? (aget item (int 1)))\n                       (try @(aget item (int 0))\n                            (catch #?(:clj Throwable\n                                      :cljs :default) _))\n                       (if-some [^objects curr (aget-aset main (int 3) item)]\n                         (aset item (int 3) curr)\n                         (if (aget main (int 5))\n                           ((.-notifier it))\n                           (aset main (int 5) true)))))\n                t #(locking it\n                     (when-some [^objects prev (aget item (int 1))]\n                       (let [^objects next (aget item (int 2))]\n                         (aset next (int 1) prev)\n                         (aset prev (int 2) next)\n                         (aset item (int 1) nil)\n                         (aset item (int 2) nil)))\n                     (done! main (.-terminator it)))]\n            (aset item (int 0)\n              (try (@(aget main (int 0)) n t)\n                   (catch #?(:clj Throwable :cljs :default) e\n                     (failer/run e n t))))\n            (if (aget main (int 5))\n              (when idle ((.-notifier it)))\n              (aset main (int 5) idle))))\n        (try @(aget main (int 0))\n             (catch #?(:clj Throwable\n                       :cljs :default) _))))))\n\n(defn gather \"\nGiven a commutative function and a flow of flows, returns a flow concurrently running the flow with flows produced by\nthis flow and producing values produced by nested flows, reduced by the function if more than one can be transferred\nsimultaneously.\n\" [rf >>x]\n  (fn [n t]\n    (let [main (object-array (int 7))\n          it (->It main rf n t)]\n      (doto main\n        (aset (int 1) main)\n        (aset (int 2) main)\n        (aset (int 4) true)\n        (aset (int 5) true)\n        (aset (int 6) 1))\n      (locking it\n        (aset main (int 0)\n          (>>x #(locking it (transfer! it))\n            #(locking it (done! main t))))\n        (transfer! it) it))))\n\n(comment\n  (require '[missionary.core :as m])\n  (def !xs (repeatedly 5 #(atom 0)))\n  (def it ((gather + (m/seed (map m/watch !xs)))\n           #(prn :ready) #(prn :done)))\n  @it\n  (swap! (nth !xs 1) inc)\n  (it)\n\n  (def failer (m/ap (throw (ex-info \"error\" {}))))\n\n  (def it ((gather + (m/seed [(m/watch (nth !xs 0))\n                              failer\n                              (m/watch (nth !xs 1))\n                              (m/observe (fn [!] (def e! !) #(prn :cancelled)))]))\n           #(prn :ready) #(prn :done)))\n  @it\n\n  (def it ((gather + failer) #(prn :ready) #(prn :done)))\n  @it\n\n  )\n"]}