{"version":3,"sources":["hyperfiddle/rcf.cljc"],"mappings":"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","names":["hyperfiddle.rcf/=","cljs.core/=","js/goog.define","hyperfiddle.rcf/ENABLED","hyperfiddle.rcf/TIMEOUT","hyperfiddle.rcf/*enabled*","var_args","args__5775__auto__","len__5769__auto__","i__5770__auto__","argseq__5776__auto__","cljs.core/IndexedSeq","hyperfiddle.rcf/enable!","p__40975","vec__40977","cljs.core.nth","seq40974","self__5755__auto__","cljs.core/seq","v","hyperfiddle.rcf/*timeout*","hyperfiddle.rcf/set-timeout!","ms","hyperfiddle.rcf/tap","x","G__40986","cljs.core.println","hyperfiddle.rcf/!","hyperfiddle.rcf/push-binding","q","d","vec__40988","c","b","_a","hyperfiddle.rcf/binding-queue","p1__40992#","!q","cljs.core.atom","push!","cljs.core.partial","cljs.core/swap!","peek!","cljs.core.get","cljs.core/deref","hyperfiddle.rcf/gen-name","form","map__41006","cljs.core/--destructure-map","line","_column","cljs.core/meta","file","clojure.string/replace","cljs.core/name","cljs.core/ns-name","cljs.core/*ns*","cljs.core.symbol","hyperfiddle.rcf/done","hyperfiddle.rcf/async-notifier","n","done","!seen","cljs.core.swap_BANG_","cljs.core/inc","G__41031","G__41032","hyperfiddle.rcf/rcf-shadow-hook","seq41047","G__41048","cljs.core/first","cljs.core/next","self__5754__auto__","build-state","args","G__41052","cljs.core/Keyword","js/Error","hyperfiddle.rcf.enable_BANG_"],"sourcesContent":["(ns hyperfiddle.rcf\n  (:refer-clojure :exclude [=])\n  #?(:cljs (:require-macros [hyperfiddle.rcf :refer [tests deftest async]]\n                            [hyperfiddle.rcf.impl :refer [make-queue]]))\n  (:require #?(:clj [hyperfiddle.rcf.impl :as impl])\n            #?(:clj [clojure.test :as t]\n               :cljs [cljs.test :as t])\n            #?(:clj [hyperfiddle.rcf.analyzer :as ana])\n            #?(:clj [clojure.walk :as walk])\n            [clojure.string :as str]\n            [hyperfiddle.rcf.reporters]\n            [hyperfiddle.rcf.queue]\n            [hyperfiddle.rcf.time]\n            [hyperfiddle.rcf.unify :as u]))\n\n(def = clojure.core/=)\n\n#?(:cljs (goog-define ^boolean ENABLED false))\n#?(:cljs (goog-define ^boolean TIMEOUT 400))\n\n;; \"Set to true if you want to generate clojure.test compatible tests. This\n;; will define testing functions in your namespace using `deftest`. Defaults to\n;; `false`.\n#?(:clj  (defonce ^:dynamic *enabled* (= \"true\" (System/getProperty \"hyperfiddle.rcf.enabled\")))\n   :cljs (def ^boolean ^:dynamic *enabled* ENABLED))\n\n(defn enable! [& [v]]\n  #?(:clj  (alter-var-root #'*enabled* (constantly (if (some? v) v true)))\n     :cljs (set! *enabled* (if (some? v) v true))))\n\n#?(:clj (def ^:dynamic *timeout* (or (System/getProperty \"hyperfiddle.rcf.timeout\") 1000))\n   :cljs (def ^:dynamic *timeout* TIMEOUT))\n\n(defn set-timeout! [ms]\n  #?(:clj (alter-var-root #'*timeout* (constantly ms))\n     :cljs (set! *timeout* ms)))\n\n#?(:clj  (def ^:dynamic *generate-tests*  (= \"true\" (System/getProperty \"hyperfiddle.rcf.generate-tests\"))))\n\n(def ^{:doc \"\nFunction to push value to async queue, e.g. `(tap 42)`. RCF redefines this var in tests context. For REPL\nconvenience, defaults to println outside of tests context.\"}\n  tap (fn [x] (doto x println)))\n\n(def ^{:doc \"Deprecated alias for `tap`.\" :deprecated true} ! tap)\n\n(comment\n  \"tap outside of tests macro\"\n  (is (= (with-out-str (tap 1)) \"1\\n\")))\n\n(def ^{:doc \"Queue behaving as a value. Assert `% := _` to pop from it. Async, will time out after `:timeout` option, default to 1000 (ms).\"}\n  %)\n\n(defn- push-binding [q d] (let [[c b _a] q] [d c b]))\n\n(defn binding-queue []\n  (let [!q    (atom [nil nil nil])\n        push! (partial swap! !q push-binding)\n        peek! #(get (deref !q) %)]\n    [push! peek!]))\n\n(defn gen-name [form]\n  (let [{:keys [line _column]} (meta form)\n        file (str/replace (name (ns-name *ns*)) #\"[-\\.]\" \"_\")]\n    (symbol (str \"generated__\" file \"_\" line))))\n\n(defmacro tests [& body]\n  (let [name (gen-name &form)]\n    (cond\n      *generate-tests* `(deftest ~name ~@body)\n      *enabled*         (if (:js-globals &env)\n                          `(do (defn ~name [] ~(impl/tests* &env body))\n                               (when *enabled* (cljs.test/run-block (cljs.test/test-var-block* (var ~name) ~name))))\n                          (impl/tests* &env body))\n      :else             nil)))\n\n(defmacro deftest\n  \"When *load-tests* is false, deftest is ignored.\"\n  [name & body]\n  (if (:js-globals &env)\n    `(do (cljs.test/deftest ~name ~(impl/tests* &env body))\n         (when *enabled* (~name)))\n    (when t/*load-tests*\n      `(do (def ~(vary-meta name assoc :test `(fn [] ~(impl/tests* &env body)))\n             (fn [] (impl/test-var (var ~name))))\n           (when *enabled* (~name))))))\n\n(defn done [])\n\n(defmacro async [done & body]\n  (if (ana/cljs? &env)\n    `(cljs.test/async ~done ~@body)\n    `(let [~done (constantly nil)]\n       ~@body)))\n\n(defn async-notifier [n done]\n  (let [!seen (atom 0)]\n    (fn []\n      (swap! !seen inc)\n      (when (= @!seen n)\n        (done)))))\n\n(defmacro make-queue [& args] (apply impl/make-queue args))\n\n(defmacro is\n  ([form] `(is ~form nil))\n  ([form msg] `(try-expr ~msg ~form)))\n\n(defmacro try-expr\n  [msg form]\n  (let [cljs? (ana/cljs? &env)\n        {:keys [file line end-line column end-column]} (meta form)]\n    `(try ~(t/assert-expr msg form)\n          (catch ~(if cljs? :default 'Throwable) t#\n            (do-report {:type :error, :message ~msg,\n                        :file ~file :line ~line :end-line ~end-line :column ~column :end-column ~end-column\n                        :expected '~form, :actual t#}))\n          (finally\n            (~'RCF__done!)))))\n\n;; Same as default `=` behavior, but returns the first argument instead of a boolean.\n\n(defmacro do-report [m]\n  (if (:js-globals &env)\n    `(cljs.test/do-report ~m)\n    `(impl/do-report ~m)))\n\n#?(:clj (defn- assert-= [menv msg form]\n          (let [[_= & args] form\n                form        (cons '= (map impl/original-form args))]\n            `(let [values# (list ~@args)\n                   result# (apply = values#)]\n               (if result#\n                 (do-report {:type     :hyperfiddle.rcf/pass\n                             :message  ~msg,\n                             :expected '~form\n                             :actual   (cons '= values#)})\n                 (do-report {:type     :hyperfiddle.rcf/fail\n                             :message  ~msg,\n                             :expected '~form\n                             :actual   (list '~'not (cons '~'= values#))}))\n               (first values#)))))\n\n#?(:clj (defmethod t/assert-expr 'hyperfiddle.rcf/= [msg form] (assert-= nil msg form)))\n\n#?(:clj\n   (defn- assert-unify [menv msg form]\n     (let [[_= & args] form\n           form        (cons := (map impl/original-form args))]\n       `(let [lhs#           (identity ~(first args))\n              rhs#           (identity ~(second args))\n              [result# env#] (u/unifier* lhs# rhs#)]\n          (if-not (u/failed? env#)\n            (do (do-report {:type     :hyperfiddle.rcf/pass\n                            :message  ~msg,\n                            :expected '~form\n                            :actual   result#})\n                result#)\n            (do (do-report {:type     :hyperfiddle.rcf/fail\n                            :message  ~msg,\n                            :expected '~form\n                            :actual   (u/explain env#)})\n                lhs#))))))\n\n#?(:clj (defmethod t/assert-expr :hyperfiddle.rcf/= [msg form] (assert-unify nil msg form)))\n\n(defmacro with\n  \"Resource cleanup helper, based on missionary's dependency-free Task protocol, see https://github.com/leonoel/task\"\n  [dispose-fn & body]\n  `(let [dispose# ~dispose-fn]\n     ~@body\n     (dispose#)))\n\n(defn rcf-shadow-hook\n  {:shadow.build/stage #{:configure :flush}}\n  [build-state & args]\n  (case (:shadow.build/stage build-state)\n    :configure (enable! false)\n    :flush (enable!))\n  build-state)\n"]}